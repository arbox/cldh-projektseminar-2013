;;; Code for the form named :main of class dialog.
;;; The inspector may add event-handler starter code here,
;;; and you may add other code for this form as well.
;;; The code for recreating the window is auto-generated into 
;;; the *.bil file having the same name as this *.cl file.

(in-package :common-graphics-user)

;;;Naiver Tokenizer ohne Berücksichtigung von Lemmata.
;;;Trennt Wörter anhand von Leerzeichen und anderen Sonderzeichen
;;;Nimmt einen String x und gibt eine Liste mit allen Tokens aus
(defun naive_tokenizer(x)
    (let
    ((s "") l)  
    (loop
    for item across x
      do (cond
          ((or (char= item #\Space) (char= item #\.) 
               (char= item #\!) (char= item #\?) 
               (char= item #\:) (char= item #\,) 
               (char= item #\;) (char= item #\"))
           (unless (equal s "") (prog1 (setq l (append l (list (string-downcase s)))) (setq s ""))))
          (t
           (setq s (concatenate 'string s (string item)))))
      )
      (unless (equal s "") (prog1 (setq l (append l (list (string-downcase s)))) (setq s "")))
      l)
  )

;;;Set-up R1 for Porter
(defun set_r(x)
  (let* ((rend (length x)) (rstart rend))
  (loop
    for item across x
    do
    (if (or (char= item #\a) (char= item #\i)
                (char= item #\u) (char= item #\e)
                (char= item #\o) (char= item #\ä)
                (char= item #\ü) (char= item #\ö))
        (cond
         ((= (position item x) (- (length x) 1)) 
          (return))
         ((and (char/= (schar x (+ 1 (position item x))) #\a) (char/= (schar x (+ 1 (position item x))) #\i)
              (char/= (schar x (+ 1 (position item x))) #\u) (char/= (schar x (+ 1 (position item x))) #\e)
              (char/= (schar x (+ 1 (position item x))) #\o) (char/= (schar x (+ 1 (position item x))) #\ä)
              (char/= (schar x (+ 1 (position item x))) #\ü) (char/= (schar x (+ 1 (position item x))) #\ö))
          (setq rstart (+ 2 (position item x)))(return)))))
    (if (>= rstart rend)
        ""
    (subseq x rstart rend))
    )
  )



              
;;;Erhält eine Liste x mit Tokens und zählt alle darin vorkommende Types
(defun typezahl(x)
  (let
      ((type '()))
  (loop
   for item in x
    do 
    (unless (find item type :test #'equal) (setf type (append type (list item))))
    )
   (list-length type))
  ) 

;;;Erhält eine Liste x Tokens und errechnet die TTR indem es die Anzahl der Types durch Anzahl der Tokens dividiert
(defun simple_TTR(x)
  (if (= (length x) 0)
      1
      (/ (typezahl x) (length x))))

;;;Erhält eine Liste x Tokens und gibt zu jedem Token die TTR aus
(defun list_TTR(x)
  (let (l)
  (loop
     for item in x
     do
        (setq l (append l (list (simple_TTR (subseq x 0 (+ 1 (position item x)))))))
    )
    l)
  )
  
  
  
  
;;;Erhält eine Liste x mit Tokens und errechent den Measure of Textual Diversity nach McCarthy (2005)
;;;muss noch getestet werden !!!
(defun mtld(x)
  (let
      ((u 0.71)  ;;Untergrenze fuer TTR
       (f 1)     ;;Faktoren / Anzahl der Textsegmente
       (c_ttr 1) ;;Derzeitiger TTR
       (sb (first x))  ;;Segmentbeginn
       (rl (reverse x))  ;;Tokenliste von hinten    
       (e))   ;;Ergebnis
    
      
    (loop
     for item in x
      do 
      (if (< c_ttr u) 
          (progn
            (setf sb item) 
            (setf f (+ f 1))
            (setf c_ttr 1)) 
          (setf c_ttr (simple_TTR (subseq x (position sb x) (position item x)))) 
               )
      )
       (setf e (/ (list-length x) f))
       (setf c_ttr 1)
       (setf f 1)
       (setf sb (first rl))
    (loop
     for item in rl
      do 
      (if (< c_ttr u) 
          (progn
            (setf sb item) 
            (setf f (+ f 1))
            (setf c_ttr 1)) 
          (setf c_ttr (simple_TTR (subseq rl (position sb rl) (position item rl)))) 
               )
      )
    (setf e (+ e (/ (list-length rl) f)))
    (setf e (/ e 2))  
      ) 
    )

;;;Generiert einen Graph des TTR-Verlaufs
(defun plot-TTR(n x y)
  (let
     ((ii 1) (TTR_Liste (list_TTR x)))
      (loop
     for item in x
      do
        (set-chart-value n :object-index 0 :item-index ii :value (nth (- ii 1) TTR_Liste))
        (setf ii (+ 1 ii)))
    )
   (let
     ((ii 1) (TTR_Liste (list_TTR y)))
      (loop
     for item in y
      do
        (set-chart-value n :object-index 1 :item-index ii  :value (nth (- ii 1) TTR_Liste))
        (setf ii (+ 1 ii)))
     )
  (setf (chart-objects n)
  (vector (list :id :Text1) (list :id :Text2)))
  )

;;;Formel für Köhler-Galle
(defun kgm_formel(x tx gtz n)
  (/ (+ tx (- gtz (/ (* gtz x) n))) n)
   )

;;;Koehler-galle-Methode
;;;erhält Tokenliste und gibt Liste mit KG-Wert für jedes Token zurück
;;;gestestet am Schiller text
(defun kgm(x)
  (let ((gtz (typezahl x))
        (n (list-length x))
        l)
  (loop
     for item in x
    do
    (setq l (append l (list (kgm_formel (+ 1 (position item x) ) (typezahl (subseq x 0 (+ 1 (position item x)))) gtz n))))
    )
    l)
  )

;;;Generiert die Ausgabe                  
(defun output (x)
  (concatenate 'string "Die Type-Token-Ratio ist: "(write-to-string (simple_TTR (naive_tokenizer x)))"
Die MTLD ist:"  (write-to-string(mtld(naive_tokenizer x)))
    ) 
  )

;;;;;;;;;;;;;;;;;;
;;;Buttons
;;;etc
;;;;;;;;;;;;;;;;;;

;;;Ereignis des Analyse1-Buttons
(defun main-analyse1-on-click (dialog widget)
  (declare (ignorable dialog widget))
  ;; NOTE:  Usually it is better to use an on-change function rather
  ;; than an on-click function.  See the doc pages for those properties.
  
  (setf (chart-items (find-sibling :TTR-PLOT widget)) nil)
  (setf (value (find-sibling :output1 widget)) (output (value (find-sibling :input1 widget))))
  (setf (value (find-sibling :output2 widget)) (output (value (find-sibling :input2 widget))))
  (plot-TTR (find-sibling :TTR-PLOT widget)
            (naive_tokenizer (value (find-sibling :input1 widget)))
            (naive_tokenizer (value (find-sibling :input2 widget))))
 (setf (value (find-sibling :test widget)) (kgm(naive_tokenizer(value (find-sibling :input1 widget)))))

  t)


;;;Ereignis des Menüpunkts "Open"
(defun datei-laden(main)
  (let
      ((c (ask-user-for-choice-from-list "In welches Fenster soll der Text geladne werden?" (list 1 2) )))
  (case c
    (1   (setf (value(find-named-object :input1 main)) (file-contents(ask-user-for-existing-pathname "Dateien Laden"))))
    (2   (setf (value(find-named-object :input2 main)) (file-contents(ask-user-for-existing-pathname "Dateien Laden")))
     )
    )
    )
  )

;;;!!!!!!!!
;;;TO-FIX
;;;
;;;-mtld
;;;-iiincredibly slooow
;;;
;;;TO-DO
;;;-a lot
;;;-